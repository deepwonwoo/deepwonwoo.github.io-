<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>1&period; Github</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <hr>
<h2 id="title-지옥에서-온-git-1버전관리의-본질layout-postdate-2020-12-31-150000author-deepwonwootags-githubcover-assetskeyboard_githubjpgcategories-github">title: (지옥에서 온 Git) 1.버전관리의 본질
layout: post
date: &quot;2020-12-31 15:00:00&quot;
author: deepwonwoo
tags: github
cover: &quot;/assets/keyboard_github.jpg&quot;
categories: github</h2>
<h1 id="1-github">1. Github</h1>
<ul>
<li><a href="#github">Github</a></li>
<li><a href="#1-git%EC%9D%B4%EB%9E%80">1. Git이란?</a></li>
<li><a href="#2-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D">2. 작동 방식</a></li>
<li><a href="#3-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4">3. 기본 명령어</a>
<ul>
<li><a href="#init">init</a></li>
<li><a href="#config">config</a></li>
<li><a href="#status">status</a></li>
<li><a href="#add">add</a></li>
<li><a href="#commit">commit</a></li>
<li><a href="#diff">diff</a></li>
<li><a href="#log">log</a></li>
<li><a href="#checkout">checkout</a></li>
<li><a href="#reset">reset</a></li>
<li><a href="#revert">revert</a></li>
</ul>
</li>
<li><a href="#4-%EA%B3%A0%EA%B8%89-%EB%AA%85%EB%A0%B9%EC%96%B4">4. 고급 명령어</a>
<ul>
<li><a href="#branch">branch</a></li>
<li><a href="#pull">pull</a></li>
<li><a href="#fetch">fetch</a></li>
<li><a href="#push">push</a></li>
</ul>
</li>
</ul>
<h1 id="2-git이란">2. Git이란?</h1>
<p>Git이란 리눅스의 아버지 <a href="https://namu.wiki/w/%EB%A6%AC%EB%88%84%EC%8A%A4%20%ED%86%A0%EB%A5%B4%EB%B0%9C%EC%8A%A4">리누스 토르발스</a>가 오픈소스 커널인 Linux 소스코드를 관리 할 목적으로 개발한 **'분산형 버전 관리 시스템'**이다. 이 형님(나보다 20살 많다)은 BitKeeper라는 분산 버전 관리 시스템을 무료로 사용했었는데, 이게 유료가 되면서 2주만에 더 업그레이드 시켜서 Git을 만들어 버렸다고 한다.</p>
<br>
<p>GIT</p>
<ul>
<li>
<p>the stupid content tracker“git” can mean anything, depending on your mood.</p>
</li>
<li>
<p>random three-letter combination that is pronounceable, and notactually used by any common UNIX command. The fact that it is a mispronounciation of “get” may or may not be relevant.</p>
</li>
<li>
<p>stupid. contemptible and despicable. simple. Take your pick from thedictionary of slang.</p>
</li>
<li>
<p>“global information tracker”: you’re in a good mood, and it actuallyworks for you. Angels sing, and a light suddenly fills the room.</p>
</li>
<li>
<p>“goddamn idiotic truckload of sh*t”: when it breaksLinus Torvalds git/git/README.md</p>
</li>
</ul>
<p>Git Repo의 리누스가 한 첫번째 커밋의 <code>README.md</code> 파일의 일부를 가져온 것인데, <code>Git</code>은 그냥 아무 의미 없는 세글자 알파벳이라고 한다. 그냥 유닉스 명령어 중에 <code>git</code>이라는 명령어가 없어서 정했다고 한다. 기분이 좋으면 “global information tracker”라고 하고 기분이 구리면 “goddamn idiotic truckload of sh*t”이란 뜻이란다.</p>
<p>Git을 이용하면 소스 코드가 변경된 이력을 쉽게 확인할 수 있고, 특정 시점에 저장된 버전과 비교하거나 특정 시점으로 되돌아갈 수도 있다. 또 내가 올리려는 파일이 누군가 편집한 내용과 충돌한다면, 서버에 업로드 할 때 경고 메시지가 발생된다.&lt;&gt;</p>
<h1 id="3-작동-방식">3. 작동 방식</h1>
<p>Git은 원격 저장소와 로컬 저장소 두 종류의 저장소를 제공한다.</p>
<ul>
<li>원격 저장소(Remote Repository): 파일이 원격 저장소 전용 서버에서 관리되며 여러 사람이 함께 공유하기 위한 저장소이다.</li>
<li>로컬 저장소(Local Repository): 내 PC에 파일이 저장되는 개인 전용 저장소이다.</li>
</ul>
<p><strong>working directory</strong></p>
<p>분산 버전 관리 시스템이기 때문에 리모트 서버에 있는 소스를 수정하려면 로컬 환경으로 소스를 클론(<strong>Clone</strong>)하는 과정이 필요하다. (혹은 <strong>git init</strong>을 이용하여 새로 git working directory 생성)</p>
<p><strong>staging area</strong></p>
<p>working directory에서 파일들을 수정하고, 로 그 파일들 중 우리가 원하는 파일들을 **&quot;add&quot;**하여 임시적으로 staging area에서 파일들을 저장한다.</p>
<p><strong>local repo</strong></p>
<p>그리고 그 staging area에 있는 파일들을 대상으로 <strong>commit</strong>하여 최종적으로 local repo에 저장한다.</p>
<p><strong>remote repo</strong></p>
<p><strong>push</strong>하여 local repo에 있는 파일들을 remote repo에 올리면 끝이 납니다.</p>
<p><img src="file:////assets/posts/gitworkflow.png" alt="사진">
git workflow</p>
<h1 id="4-기본-명령어">4. 기본 명령어</h1>
<h3 id="401-init">4.0.1. init</h3>
<p>버전관리 원하는 폴더 위치에서 명령어를 실행하면 .init 파일이 생긴다. 절대 삭제하지 말아야 한다.</p>
<pre><code class="language-bash"><div>$ git init
</div></code></pre>
<h3 id="402-config">4.0.2. config</h3>
<p>git config: Git 사용자 정보를 설정한다.(최초 1회만 실행)</p>
<pre><code class="language-bash"><div>$ git config --global user.name <span class="hljs-string">&quot;deepwonwoo&quot;</span>
$ git config --global user.email <span class="hljs-string">&quot;deepwonwoo&quot;</span>
</div></code></pre>
<h3 id="403-status">4.0.3. status</h3>
<p>저장소의 상태/working tree status를 확인할수있다.</p>
<pre><code class="language-bash"><div>$ git status
</div></code></pre>
<h3 id="404-add">4.0.4. add</h3>
<pre><code class="language-bash"><div>$ git add {file}       <span class="hljs-comment"># 해당 파일을 staging area로 추가</span>
$ git add {directory}  <span class="hljs-comment"># 해당 폴더를 staging area로 추가</span>
$ git add .  <span class="hljs-comment"># 현재 디렉토리에 있는 모든 파일을 stating area로 추가</span>
</div></code></pre>
<h3 id="405-commit">4.0.5. commit</h3>
<pre><code class="language-bash"><div>$ git commit -m <span class="hljs-string">&quot;메세지&quot;</span>       <span class="hljs-comment"># 작업 후 특정 메세지를 작성하여 버전을 생성</span>
$ git commit -am <span class="hljs-string">&quot;메세지&quot;</span>      <span class="hljs-comment"># add와 commit을 한번에 수행</span>
$ git commit                   <span class="hljs-comment"># 여러줄의 커밋 메세지를 편집기를 통해 작성</span>
$ git commit  --amend          <span class="hljs-comment"># 이전 커밋 메세지를 편집기를 통해 수정</span>
</div></code></pre>
<h3 id="406-diff">4.0.6. diff</h3>
<pre><code class="language-bash"><div>$ git diff           <span class="hljs-comment"># 변경사항을 볼수있다. 커밋전에 활용하자!</span>
</div></code></pre>
<h3 id="407-log">4.0.7. log</h3>
<pre><code class="language-bash"><div>$ git <span class="hljs-built_in">log</span>  <span class="hljs-comment"># 로컬 저장소의 커밋 히스토리를 탐색한다</span>
$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span>  <span class="hljs-comment"># 버전마다 관련된 파일들을 그룹핑하여 확인</span>
$ git <span class="hljs-built_in">log</span> -p      <span class="hljs-comment"># 아주 복잡한 코드일 경우 문제가 생긴 코드를 추적할 때 확인하기 좋다.</span>
</div></code></pre>
<h3 id="408-checkout">4.0.8. checkout</h3>
<pre><code class="language-bash"><div>$ git checkout {커밋ID}  <span class="hljs-comment"># 해당 커밋ID를 입력하면 그 커밋의 작업시점으로 돌아간다.</span>
                         <span class="hljs-comment"># 즉, head를 이동하면서 과거와 현재를 왔다갔다 하면서 탐색할수 있다.</span>
                         <span class="hljs-comment"># head=&gt;master 가 붙어있는 커밋이 가장 최근 커밋이다.</span>
$ git checkout {브랜치명}  <span class="hljs-comment"># 로컬 저장소에서 해당 이름의 브랜치로 전환</span>
</div></code></pre>
<h3 id="409-reset">4.0.9. reset</h3>
<pre><code class="language-bash"><div>$ git reset --hard {원하는버전의 커밋ID}  <span class="hljs-comment"># 현재 작업 내용을 삭제하고 원하는 버전으로 복원</span>
                                         <span class="hljs-comment"># (공유되기 전 단계의 버전만 할수있다)</span>
$ git reset --hard HEAD^             <span class="hljs-comment"># 최종 커밋 취소하고 파일까지 복구</span>
</div></code></pre>
<h3 id="4010-revert">4.0.10. revert</h3>
<pre><code class="language-bash"><div>$ git revert {현재버전커밋ID}     <span class="hljs-comment"># 기존의 커밋은 내버려두고 이전 커밋으로 복원</span>
                                 <span class="hljs-comment"># 기존 커밋은 사라지지 않는 것이 reset과는 다른점</span>
</div></code></pre>
<h1 id="5-고급-명령어">5. 고급 명령어</h1>
<h3 id="501-branch">5.0.1. branch</h3>
<p>똑같은 작업물을 가진 공통 저장소를 기반으로 각자 다른 작업을 병행하며 진행</p>
<pre><code class="language-bash"><div>$ git branch           <span class="hljs-comment"># 브랜치 목록을 보여준다. 레포지토리를 생성하면 기본으로 master라는 기본 브랜치가 있다.</span>
$ git branch login     <span class="hljs-comment"># 특정 이름을 가진 브랜치를 생성한다.</span>
$ git checkout main    <span class="hljs-comment"># 다른 브랜치로 이동할 수 있다.</span>
$ git <span class="hljs-built_in">log</span> --all --graph --oneline <span class="hljs-comment"># 모든 브랜치를 한 줄 씩 그래프 형태로 볼 수 있는 명령어이다.</span>
</div></code></pre>
<h3 id="502-pull">5.0.2. pull</h3>
<p><code>pull</code>명령어는 리모트 서버의 최신 소스를 가져와서 로컬 소스에 병합(Merge)해주는 명령어이다. 만약 우리가 처음 소스를 클론한 후에 다른 사람이 리모트 서버를 상태를 갱신했더라도 리모트 서버가 우리에게 그 변경된 사항을 알려주지는 않기 때문에 우리가 직접 서버에 문의를 날려야 하는 것이다.</p>
<p>예를 들어 공동 작업물을 로컬저장소에서 작업해야할 때 이 명령어를 먼저 실행한 후에 작업한다.</p>
<ul>
<li>여려명이 함께 작업할 때 프로세스 : pull - 작업 - commit - push</li>
</ul>
<p>또한 <code>pull</code>은 단순히 리모트 서버에서 로컬로 소스를 가져온다의 개념보다는 <code>가져와서 합친다</code>의 개념이기 때문에 브랜치끼리도 <code>pull</code>을 통해 소스를 합칠 수 있다.</p>
<pre><code class="language-bash"><div>$ git pull <span class="hljs-comment"># 현재 내 로컬 브랜치와 같은 이름을 가진 리모트 서버 브랜치가 타겟</span>
$ git pull origin master <span class="hljs-comment"># origin 리모트 서버의 master 브랜치가 타겟</span>
</div></code></pre>
<p>오픈소스에 관심이 많은 분이라면 <code>Pull Request</code>라는 단어를 들어보았을 것이다. 이 <code>Pull Request</code>는 “내가 작업한 브랜치를 가져가서 합쳐줘~“라는 의미이다. Merge Request가 아닌 이유는 요청을 받은 사람 입장에서 브랜치를 가져와서 합친기 때문이다.</p>
<h3 id="503-fetch">5.0.3. fetch</h3>
<p><code>fetch</code> 는 리모트 서버의 최신 이력을 내 클라이언트로 가져오되 병합은 하지 않는 명령어이다.</p>
<pre><code class="language-bash"><div>$ git fetch

$ git branch -vv
* master fa0cec5 [origin/master] 마스터 브랜치에욤
  <span class="hljs-built_in">test</span>   1f3578f [origin/<span class="hljs-built_in">test</span>: gone] 리모트에선 죽은 브랜치
  test2  fa0cec5 로컬에서 만들어지고 리모트에 업데이트는 안된 브랜치
</div></code></pre>
<p><code>fetch</code> 명령어를 사용하면 다른 사람들이 리모트 서버에 새로 업데이트한 모든 내역을 받아올 수 있다. 이제 그 내역을 보고 내 로컬에 있는 버전이 리모트 서버에 있는 버전보다 이전 버전이라면 <code>pull</code> 명령어를 사용하여 내 컴퓨터의 소스 코드를 갱신하면 된다.</p>
<p>그럼 이 명령어가 <code>pull</code>의 하위 호환이 아닌가? 라는 생각이 들 수도 있는데, <code>pull</code>과 <code>fetch</code>는 조금 용도가 다르긴 하다. <code>pull</code> 같은 경우는 일단 묻지도 따지지도 않고 바로 리모트 서버의 최신 소스를 가져와서 내 로컬 소스에 합쳐버리기 때문에 조금 위험하긴 하다. 뭐 예를 들면 지금 리모트 서버의 최신 소스가 버그가 있는 상태일 수도 있지 않은가?</p>
<h3 id="504-push">5.0.4. push</h3>
<pre><code class="language-bash"><div>$ git push origin master <span class="hljs-comment"># origin 리모트 서버의 master 브랜치로 푸쉬해줘!</span>
</div></code></pre>
<p>근데 이게 브랜치 이름이 <code>master</code>정도면 그래도 브랜치 이름을 매번 입력해줄만 하지만 <code>feature/SD-0000-request-api-refactoring</code> 정도 되면 브랜치 이름을 매번 입력한다는 것이 귀찮을 수도 있다.</p>
<p>그래서 Git은 브랜치를 자동으로 추적할 수 있는 기능 또한 제공해준다.</p>
<p><code>$ git push --set-upstream origin master</code></p>
<p><code>-set-upstream</code> 옵션을 사용하고 처음 한번만 브랜치 이름을 입력해주면 그 이후로는 <code>git push</code> 명령어만 입력해도 자동으로 처음 입력했던 브랜치로 변경 사항을 푸쉬할 수 있다.</p>

    </body>
    </html>